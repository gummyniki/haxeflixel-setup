// Generated by Haxe 4.3.6
#include <hxcpp.h>

#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_input_FlxInput
#include <flixel/input/FlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_actions_FlxActionInput
#include <flixel/input/actions/FlxActionInput.h>
#endif
#ifndef INCLUDED_flixel_input_actions_FlxActionInputAnalog
#include <flixel/input/actions/FlxActionInputAnalog.h>
#endif
#ifndef INCLUDED_flixel_input_actions_FlxActionInputAnalogGamepad
#include <flixel/input/actions/FlxActionInputAnalogGamepad.h>
#endif
#ifndef INCLUDED_flixel_input_actions_FlxInputDevice
#include <flixel/input/actions/FlxInputDevice.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepad
#include <flixel/input/gamepad/FlxGamepad.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepadButton
#include <flixel/input/gamepad/FlxGamepadButton.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepadManager
#include <flixel/input/gamepad/FlxGamepadManager.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxTypedGamepadAnalogStick
#include <flixel/input/gamepad/FlxTypedGamepadAnalogStick.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_lists_FlxBaseGamepadList
#include <flixel/input/gamepad/lists/FlxBaseGamepadList.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_lists_FlxGamepadAnalogList
#include <flixel/input/gamepad/lists/FlxGamepadAnalogList.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_lists_FlxGamepadAnalogValueList
#include <flixel/input/gamepad/lists/FlxGamepadAnalogValueList.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_lists_FlxGamepadButtonList
#include <flixel/input/gamepad/lists/FlxGamepadButtonList.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_mappings_FlxTypedGamepadMapping
#include <flixel/input/gamepad/mappings/FlxTypedGamepadMapping.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_c9d761a2eac45f19_205_new,"flixel.input.actions.FlxActionInputAnalogGamepad","new",0xd9f55bba,"flixel.input.actions.FlxActionInputAnalogGamepad.new","flixel/input/actions/FlxActionInputAnalog.hx",205,0x00ad3122)
HX_LOCAL_STACK_FRAME(_hx_pos_c9d761a2eac45f19_209_update,"flixel.input.actions.FlxActionInputAnalogGamepad","update",0xc42a0eef,"flixel.input.actions.FlxActionInputAnalogGamepad.update","flixel/input/actions/FlxActionInputAnalog.hx",209,0x00ad3122)
namespace flixel{
namespace input{
namespace actions{

void FlxActionInputAnalogGamepad_obj::__construct(int InputID,int Trigger,::hx::Null< int >  __o_Axis,::hx::Null< int >  __o_GamepadID){
            		int Axis = __o_Axis.Default(3);
            		int GamepadID = __o_GamepadID.Default(-2);
            	HX_STACKFRAME(&_hx_pos_c9d761a2eac45f19_205_new)
HXDLIN( 205)		super::__construct(::flixel::input::actions::FlxInputDevice_obj::GAMEPAD_dyn(),InputID,Trigger,Axis,GamepadID);
            	}

Dynamic FlxActionInputAnalogGamepad_obj::__CreateEmpty() { return new FlxActionInputAnalogGamepad_obj; }

void *FlxActionInputAnalogGamepad_obj::_hx_vtable = 0;

Dynamic FlxActionInputAnalogGamepad_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< FlxActionInputAnalogGamepad_obj > _hx_result = new FlxActionInputAnalogGamepad_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3]);
	return _hx_result;
}

bool FlxActionInputAnalogGamepad_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x5e4ab4dc) {
		if (inClassId<=(int)0x20308a99) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x20308a99;
		} else {
			return inClassId==(int)0x5e4ab4dc;
		}
	} else {
		return inClassId==(int)0x7f995ee1;
	}
}

void FlxActionInputAnalogGamepad_obj::update(){
            	HX_STACKFRAME(&_hx_pos_c9d761a2eac45f19_209_update)
HXLINE( 210)		if ((this->deviceID == -1)) {
HXLINE( 212)			return;
            		}
HXLINE( 216)		 ::flixel::input::gamepad::FlxGamepad gamepad = null();
HXLINE( 218)		if ((this->deviceID == -2)) {
HXLINE( 220)			gamepad = ::flixel::FlxG_obj::gamepads->getFirstActiveGamepad();
            		}
            		else {
HXLINE( 222)			if ((this->deviceID >= 0)) {
HXLINE( 224)				gamepad = ::flixel::FlxG_obj::gamepads->_activeGamepads->__get(this->deviceID).StaticCast<  ::flixel::input::gamepad::FlxGamepad >();
            			}
            		}
HXLINE( 227)		if (::hx::IsNotNull( gamepad )) {
HXLINE( 229)			switch((int)(this->inputID)){
            				case (int)17: {
HXLINE( 238)					this->updateValues(gamepad->analog->value->gamepad->getAxis(17),( (Float)(0) ));
            				}
            				break;
            				case (int)18: {
HXLINE( 241)					this->updateValues(gamepad->analog->value->gamepad->getAxis(18),( (Float)(0) ));
            				}
            				break;
            				case (int)19: {
HXLINE( 232)					 ::flixel::input::gamepad::FlxGamepad _this = gamepad->analog->value->gamepad;
HXDLIN( 232)					Float _hx_tmp = _this->getAnalogXAxisValue(_this->mapping->getAnalogStick(19));
HXDLIN( 232)					 ::flixel::input::gamepad::FlxGamepad _this1 = gamepad->analog->value->gamepad;
HXDLIN( 232)					this->updateValues(_hx_tmp,_this1->getYAxisRaw(_this1->mapping->getAnalogStick(19)));
            				}
            				break;
            				case (int)20: {
HXLINE( 235)					 ::flixel::input::gamepad::FlxGamepad _this2 = gamepad->analog->value->gamepad;
HXDLIN( 235)					Float _hx_tmp1 = _this2->getAnalogXAxisValue(_this2->mapping->getAnalogStick(20));
HXDLIN( 235)					 ::flixel::input::gamepad::FlxGamepad _this3 = gamepad->analog->value->gamepad;
HXDLIN( 235)					this->updateValues(_hx_tmp1,_this3->getYAxisRaw(_this3->mapping->getAnalogStick(20)));
            				}
            				break;
            				case (int)21: {
HXLINE( 250)					Float _hx_tmp2;
HXDLIN( 250)					 ::flixel::input::gamepad::lists::FlxGamepadButtonList _this4 = gamepad->pressed;
HXDLIN( 250)					int id = 13;
HXDLIN( 250)					 ::flixel::input::gamepad::FlxGamepad _this5 = _this4->gamepad;
HXDLIN( 250)					int Status = _this4->status;
HXDLIN( 250)					bool _hx_tmp3;
HXDLIN( 250)					switch((int)(id)){
            						case (int)-2: {
HXLINE( 250)							_hx_tmp3 = _this5->anyButton(Status);
            						}
            						break;
            						case (int)-1: {
HXLINE( 250)							_hx_tmp3 = !(_this5->anyButton(Status));
            						}
            						break;
            						default:{
HXLINE( 250)							int RawID = ( (int)(_this5->mapping->getRawID(id)) );
HXDLIN( 250)							 ::flixel::input::gamepad::FlxGamepadButton button = _this5->buttons->__get(RawID).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 250)							if (::hx::IsNotNull( button )) {
HXLINE( 250)								_hx_tmp3 = button->hasState(Status);
            							}
            							else {
HXLINE( 250)								_hx_tmp3 = false;
            							}
            						}
            					}
HXDLIN( 250)					if (_hx_tmp3) {
HXLINE( 250)						_hx_tmp2 = ((Float)-1.0);
            					}
            					else {
HXLINE( 250)						 ::flixel::input::gamepad::lists::FlxGamepadButtonList _this6 = gamepad->pressed;
HXDLIN( 250)						int id1 = 14;
HXDLIN( 250)						 ::flixel::input::gamepad::FlxGamepad _this7 = _this6->gamepad;
HXDLIN( 250)						int Status1 = _this6->status;
HXDLIN( 250)						bool _hx_tmp4;
HXDLIN( 250)						switch((int)(id1)){
            							case (int)-2: {
HXLINE( 250)								_hx_tmp4 = _this7->anyButton(Status1);
            							}
            							break;
            							case (int)-1: {
HXLINE( 250)								_hx_tmp4 = !(_this7->anyButton(Status1));
            							}
            							break;
            							default:{
HXLINE( 250)								int RawID1 = ( (int)(_this7->mapping->getRawID(id1)) );
HXDLIN( 250)								 ::flixel::input::gamepad::FlxGamepadButton button1 = _this7->buttons->__get(RawID1).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 250)								if (::hx::IsNotNull( button1 )) {
HXLINE( 250)									_hx_tmp4 = button1->hasState(Status1);
            								}
            								else {
HXLINE( 250)									_hx_tmp4 = false;
            								}
            							}
            						}
HXDLIN( 250)						if (_hx_tmp4) {
HXLINE( 250)							_hx_tmp2 = ((Float)1.0);
            						}
            						else {
HXLINE( 250)							_hx_tmp2 = ((Float)0.0);
            						}
            					}
HXLINE( 251)					Float _hx_tmp5;
HXDLIN( 251)					 ::flixel::input::gamepad::lists::FlxGamepadButtonList _this8 = gamepad->pressed;
HXDLIN( 251)					int id2 = 11;
HXDLIN( 251)					 ::flixel::input::gamepad::FlxGamepad _this9 = _this8->gamepad;
HXDLIN( 251)					int Status2 = _this8->status;
HXDLIN( 251)					bool _hx_tmp6;
HXDLIN( 251)					switch((int)(id2)){
            						case (int)-2: {
HXLINE( 251)							_hx_tmp6 = _this9->anyButton(Status2);
            						}
            						break;
            						case (int)-1: {
HXLINE( 251)							_hx_tmp6 = !(_this9->anyButton(Status2));
            						}
            						break;
            						default:{
HXLINE( 251)							int RawID2 = ( (int)(_this9->mapping->getRawID(id2)) );
HXDLIN( 251)							 ::flixel::input::gamepad::FlxGamepadButton button2 = _this9->buttons->__get(RawID2).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 251)							if (::hx::IsNotNull( button2 )) {
HXLINE( 251)								_hx_tmp6 = button2->hasState(Status2);
            							}
            							else {
HXLINE( 251)								_hx_tmp6 = false;
            							}
            						}
            					}
HXDLIN( 251)					if (_hx_tmp6) {
HXLINE( 251)						_hx_tmp5 = ((Float)-1.0);
            					}
            					else {
HXLINE( 251)						 ::flixel::input::gamepad::lists::FlxGamepadButtonList _this10 = gamepad->pressed;
HXDLIN( 251)						int id3 = 12;
HXDLIN( 251)						 ::flixel::input::gamepad::FlxGamepad _this11 = _this10->gamepad;
HXDLIN( 251)						int Status3 = _this10->status;
HXDLIN( 251)						bool _hx_tmp7;
HXDLIN( 251)						switch((int)(id3)){
            							case (int)-2: {
HXLINE( 251)								_hx_tmp7 = _this11->anyButton(Status3);
            							}
            							break;
            							case (int)-1: {
HXLINE( 251)								_hx_tmp7 = !(_this11->anyButton(Status3));
            							}
            							break;
            							default:{
HXLINE( 251)								int RawID3 = ( (int)(_this11->mapping->getRawID(id3)) );
HXDLIN( 251)								 ::flixel::input::gamepad::FlxGamepadButton button3 = _this11->buttons->__get(RawID3).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 251)								if (::hx::IsNotNull( button3 )) {
HXLINE( 251)									_hx_tmp7 = button3->hasState(Status3);
            								}
            								else {
HXLINE( 251)									_hx_tmp7 = false;
            								}
            							}
            						}
HXDLIN( 251)						if (_hx_tmp7) {
HXLINE( 251)							_hx_tmp5 = ((Float)1.0);
            						}
            						else {
HXLINE( 251)							_hx_tmp5 = ((Float)0.0);
            						}
            					}
HXLINE( 250)					this->updateValues(_hx_tmp2,_hx_tmp5);
            				}
            				break;
            				case (int)28: {
HXLINE( 244)					this->updateValues(gamepad->analog->value->gamepad->getAxis(28),( (Float)(0) ));
            				}
            				break;
            				case (int)29: {
HXLINE( 247)					this->updateValues(gamepad->analog->value->gamepad->getAxis(29),( (Float)(0) ));
            				}
            				break;
            			}
            		}
            		else {
HXLINE( 256)			this->updateValues(( (Float)(0) ),( (Float)(0) ));
            		}
            	}



::hx::ObjectPtr< FlxActionInputAnalogGamepad_obj > FlxActionInputAnalogGamepad_obj::__new(int InputID,int Trigger,::hx::Null< int >  __o_Axis,::hx::Null< int >  __o_GamepadID) {
	::hx::ObjectPtr< FlxActionInputAnalogGamepad_obj > __this = new FlxActionInputAnalogGamepad_obj();
	__this->__construct(InputID,Trigger,__o_Axis,__o_GamepadID);
	return __this;
}

::hx::ObjectPtr< FlxActionInputAnalogGamepad_obj > FlxActionInputAnalogGamepad_obj::__alloc(::hx::Ctx *_hx_ctx,int InputID,int Trigger,::hx::Null< int >  __o_Axis,::hx::Null< int >  __o_GamepadID) {
	FlxActionInputAnalogGamepad_obj *__this = (FlxActionInputAnalogGamepad_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(FlxActionInputAnalogGamepad_obj), true, "flixel.input.actions.FlxActionInputAnalogGamepad"));
	*(void **)__this = FlxActionInputAnalogGamepad_obj::_hx_vtable;
	__this->__construct(InputID,Trigger,__o_Axis,__o_GamepadID);
	return __this;
}

FlxActionInputAnalogGamepad_obj::FlxActionInputAnalogGamepad_obj()
{
}

::hx::Val FlxActionInputAnalogGamepad_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *FlxActionInputAnalogGamepad_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *FlxActionInputAnalogGamepad_obj_sStaticStorageInfo = 0;
#endif

static ::String FlxActionInputAnalogGamepad_obj_sMemberFields[] = {
	HX_("update",09,86,05,87),
	::String(null()) };

::hx::Class FlxActionInputAnalogGamepad_obj::__mClass;

void FlxActionInputAnalogGamepad_obj::__register()
{
	FlxActionInputAnalogGamepad_obj _hx_dummy;
	FlxActionInputAnalogGamepad_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flixel.input.actions.FlxActionInputAnalogGamepad",c8,b6,82,3c);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(FlxActionInputAnalogGamepad_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< FlxActionInputAnalogGamepad_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxActionInputAnalogGamepad_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxActionInputAnalogGamepad_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace flixel
} // end namespace input
} // end namespace actions
